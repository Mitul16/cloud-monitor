"""
Main driver code that runs the agent.
This file is autorun on `python attestation_agent` command.
"""

from concurrent.futures import ThreadPoolExecutor
import json
import time
from collections import deque

import requests
import socketio

from .config import *
from .logs.parsers import *

# How long to wait (in seconds) to start re-parsing any new content in the log file
# and send events to the attestation server
WAIT_INTERVAL = 60

# Machine ID stored in `/etc/machine-id` or in a custom location
MACHINE_ID: str = None

# Global objects below
# SocketIO object for real-time communication with the attestation server
# For instance, to receive updates from the server
io = socketio.Client()

# ThreadPoolExecutor instance to execute loggers and parsers
# in separate threads for concurrency via multi-threading
tpe: ThreadPoolExecutor = None

# Log parsers to parse logs and send events to the attestation server
PARSERS = (
    AuthParser(AUTH_LOG),
    AuditParser(AUDIT_LOG),
)


def read_machine_id(filepath: str):
    """
    Read the machine ID from given path and set the global variable
    """
    global MACHINE_ID

    DEFAULT_PATH = "/etc/machine-id"
    path = DEFAULT_PATH if filepath is None else filepath

    with open(path) as fp:
        MACHINE_ID = fp.read().strip()
        print(f"Found machine-id: {MACHINE_ID}")


def handle_events(events: deque[Event]) -> None:
    """
    Iterate over the events, convert their data to the appropriate format
    and send to the attestation server.
    """
    while events:
        event = events.popleft()

        # Prepare data to send
        event_dict = {
            "machine_id": MACHINE_ID,
            "timestamp": event.timestamp,
            "type": event.type,
            "log_filepath": event.log_file,
            "props": "",
        }

        # Extract attributes of event
        event_props = {
            key: value for key, value in event.__dict__.items() if key not in event_dict
        }

        # Marshal the attributes and send to the attestation server
        event_dict["props"] = json.dumps(event_props)
        _ = requests.post(url=f"{BASE_URL}/api/event/add", json=event_dict)

        # TODO: Send logs separately via a logger
        # If we get a ParseError, we don't get an Event object
        # and nothing is sent to the server

        # Send raw event log (line in log file) to the attestation server
        event_log = event_dict.copy()
        _ = event_log.pop("props")
        event_log["content"] = event.raw_content
        _ = requests.post(url=f"{BASE_URL}/api/log/add", json=event_log)


def main():
    """
    Initialize the agent to run loggers and parsers in their separate threads
    """
    global io, tpe

    # Read the machine ID from given path
    read_machine_id(MACHINE_ID_PATH)

    # Connect to attestation server, creating a websocket connection
    # for real-time communication
    print(f"Connecting to the attestation server: {BASE_URL} ... ", end="", flush=True)

    # Try to connect to the server
    try:
        io.connect(BASE_URL)
        print(f"connected!")
        print(f"Got socketID: {io.sid}")
    except:
        io = None
        print(
            "Failed to connect to the attestation server."
            "Make sure the server is running and accessible."
        )

    # Initialize a thread pool of 8 threads
    tpe = ThreadPoolExecutor(max_workers=8)

    # Function to run the parser
    runner_func = lambda obj: obj.run()

    # Run the parsers in a separate thread each
    _ = tpe.map(runner_func, PARSERS)

    # Infinite loop:
    # - pick a parser
    # - pause it, read its events, resume it
    # - pick next and repeat
    while True:
        # Temporarily suspend each parser and get the events generated by it (if any)
        # and send them to the attestation server
        for parser in PARSERS:
            with parser.lock:
                events = parser.flush()

            # Handle the generated events
            handle_events(events)

        time.sleep(WAIT_INTERVAL)


if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        # TODO: Save agent state to prevent re-parsing
        # of already parsed logs

        print("Waiting for parsers to finish ... ", end="", flush=True)

        for parser in PARSERS:
            parser.stop()

        tpe.shutdown()
        exit("exiting...")
